# 健康AI助手 - 技术实现指南

## 🏗️ 技术架构总览

```
前端层：Next.js 15 + TypeScript + Tailwind CSS + Supabase Client
    ↓ HTTP/WebSocket
API层：Python FastAPI + Pydantic + SQLAlchemy  
    ↓ 
服务层：Azure OpenAI + EasyOCR + Supabase Storage
    ↓
数据层：Supabase PostgreSQL + Redis Cache
```

## 🐍 Python后端环境搭建

### 1. 项目结构设计
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI主程序
│   ├── config.py              # 配置文件
│   ├── dependencies.py        # 依赖注入
│   ├── models/                # 数据模型
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── report.py
│   │   └── health.py
│   ├── schemas/               # Pydantic模式
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── report.py
│   │   └── health.py
│   ├── api/                   # API路由
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── reports.py
│   │   ├── chat.py
│   │   └── health.py
│   ├── services/              # 业务逻辑服务
│   │   ├── __init__.py
│   │   ├── ocr_service.py
│   │   ├── ai_service.py
│   │   ├── report_service.py
│   │   └── health_service.py
│   ├── utils/                 # 工具函数
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── file_handler.py
│   │   └── validators.py
│   └── core/                  # 核心配置
│       ├── __init__.py
│       ├── database.py
│       ├── security.py
│       └── settings.py
├── tests/                     # 测试文件
├── requirements.txt           # 依赖列表
├── Dockerfile                # Docker配置
└── README.md                 # 文档
```

### 2. 核心依赖 (requirements.txt)
```txt
# Web框架
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# 数据库
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
alembic==1.13.1

# Supabase集成
supabase==2.2.0
postgrest==0.11.0

# AI服务
openai==1.3.9
azure-cognitiveservices-vision-computervision==0.9.0
azure-identity==1.15.0

# OCR
easyocr==1.7.0
opencv-python==4.8.1.78
Pillow==10.1.0

# 工具库
pydantic==2.5.2
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-dotenv==1.0.0
httpx==0.25.2
redis==5.0.1

# 文件处理
PyPDF2==3.0.1
pdf2image==1.16.3
poppler-utils==0.1.0

# 数据处理
pandas==2.1.4
numpy==1.26.2
```

### 3. 基础配置 (app/core/settings.py)
```python
from pydantic_settings import BaseSettings
from typing import Optional
import os

class Settings(BaseSettings):
    # 应用配置
    APP_NAME: str = "健康AI助手"
    VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # 数据库配置
    SUPABASE_URL: str
    SUPABASE_KEY: str
    SUPABASE_SERVICE_KEY: str
    DATABASE_URL: str
    
    # Azure OpenAI配置
    AZURE_OPENAI_ENDPOINT: str
    AZURE_OPENAI_KEY: str
    AZURE_OPENAI_VERSION: str = "2023-12-01-preview"
    AZURE_OPENAI_DEPLOYMENT: str = "gpt-4"
    
    # Redis配置
    REDIS_URL: str = "redis://localhost:6379"
    
    # 文件上传配置
    MAX_FILE_SIZE: int = 10 * 1024 * 1024  # 10MB
    ALLOWED_EXTENSIONS: list = [".pdf", ".jpg", ".jpeg", ".png"]
    UPLOAD_PATH: str = "uploads/"
    
    # 安全配置
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # OCR配置
    OCR_LANGUAGES: list = ['ch_sim', 'en']
    OCR_GPU: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()
```

## 🔤 EasyOCR服务实现

### 1. OCR服务核心类 (app/services/ocr_service.py)
```python
import easyocr
import cv2
import numpy as np
from PIL import Image
import io
import re
from typing import List, Dict, Tuple, Optional
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class HealthReportOCR:
    def __init__(self, languages=['ch_sim', 'en'], gpu=False):
        """初始化OCR服务"""
        try:
            self.reader = easyocr.Reader(languages, gpu=gpu)
            self.health_keywords = self._load_health_keywords()
            logger.info("OCR服务初始化成功")
        except Exception as e:
            logger.error(f"OCR服务初始化失败: {e}")
            raise
    
    def _load_health_keywords(self) -> Dict[str, List[str]]:
        """加载健康指标关键词库"""
        return {
            "血常规": [
                "白细胞", "WBC", "红细胞", "RBC", "血红蛋白", "HGB", "血小板", "PLT",
                "中性粒细胞", "淋巴细胞", "单核细胞", "嗜酸性粒细胞"
            ],
            "血脂": [
                "总胆固醇", "TC", "甘油三酯", "TG", "高密度脂蛋白", "HDL",
                "低密度脂蛋白", "LDL", "载脂蛋白"
            ],
            "肝功能": [
                "丙氨酸氨基转移酶", "ALT", "天门冬氨酸氨基转移酶", "AST",
                "总胆红素", "直接胆红素", "间接胆红素", "白蛋白", "ALB"
            ],
            "肾功能": [
                "尿素氮", "BUN", "肌酐", "Cr", "尿酸", "UA", "胱抑素C"
            ],
            "血糖": [
                "空腹血糖", "FBG", "糖化血红蛋白", "HbA1c", "餐后血糖"
            ]
        }
    
    def preprocess_image(self, image_path: str) -> np.ndarray:
        """图像预处理，提高OCR识别率"""
        try:
            # 读取图像
            image = cv2.imread(image_path)
            if image is None:
                raise ValueError(f"无法读取图像: {image_path}")
            
            # 转换为灰度图
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # 自适应阈值处理
            thresh = cv2.adaptiveThreshold(
                gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                cv2.THRESH_BINARY, 11, 2
            )
            
            # 形态学操作去噪
            kernel = np.ones((1, 1), np.uint8)
            cleaned = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)
            
            return cleaned
            
        except Exception as e:
            logger.error(f"图像预处理失败: {e}")
            return cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    
    def extract_text(self, image_path: str, preprocess: bool = True) -> List[Tuple[str, float]]:
        """提取图片中的文字"""
        try:
            if preprocess:
                # 使用预处理后的图像
                processed_image = self.preprocess_image(image_path)
                results = self.reader.readtext(processed_image)
            else:
                # 直接使用原图
                results = self.reader.readtext(image_path)
            
            # 提取文本和置信度
            extracted_text = []
            for (bbox, text, confidence) in results:
                if confidence > 0.5:  # 只保留置信度大于0.5的结果
                    extracted_text.append((text.strip(), confidence))
            
            logger.info(f"成功提取 {len(extracted_text)} 个文本片段")
            return extracted_text
            
        except Exception as e:
            logger.error(f"文字提取失败: {e}")
            return []
    
    def parse_health_indicators(self, text_data: List[Tuple[str, float]]) -> Dict[str, any]:
        """解析健康指标数据"""
        try:
            indicators = {}
            text_list = [item[0] for item in text_data]
            full_text = " ".join(text_list)
            
            # 数值匹配正则表达式
            number_pattern = r'(\d+\.?\d*)'
            unit_pattern = r'([a-zA-Z/%]+)'
            
            for category, keywords in self.health_keywords.items():
                category_indicators = {}
                
                for keyword in keywords:
                    # 在文本中查找关键词
                    keyword_matches = self._find_keyword_context(full_text, keyword)
                    
                    for match in keyword_matches:
                        # 提取数值和单位
                        values = self._extract_values_near_keyword(text_list, keyword)
                        if values:
                            category_indicators[keyword] = values
                
                if category_indicators:
                    indicators[category] = category_indicators
            
            return indicators
            
        except Exception as e:
            logger.error(f"健康指标解析失败: {e}")
            return {}
    
    def _find_keyword_context(self, text: str, keyword: str, context_size: int = 50) -> List[str]:
        """查找关键词及其上下文"""
        matches = []
        text_lower = text.lower()
        keyword_lower = keyword.lower()
        
        start = 0
        while True:
            pos = text_lower.find(keyword_lower, start)
            if pos == -1:
                break
                
            # 提取上下文
            context_start = max(0, pos - context_size)
            context_end = min(len(text), pos + len(keyword) + context_size)
            context = text[context_start:context_end]
            matches.append(context)
            
            start = pos + 1
        
        return matches
    
    def _extract_values_near_keyword(self, text_list: List[str], keyword: str) -> Optional[Dict]:
        """提取关键词附近的数值"""
        for i, text in enumerate(text_list):
            if keyword in text or keyword.upper() in text:
                # 在当前文本和邻近文本中查找数值
                search_range = text_list[max(0, i-2):min(len(text_list), i+3)]
                search_text = " ".join(search_range)
                
                # 数值提取
                numbers = re.findall(r'\d+\.?\d*', search_text)
                units = re.findall(r'[a-zA-Z/%]+', search_text)
                
                if numbers:
                    return {
                        "value": float(numbers[0]) if numbers[0] else None,
                        "unit": units[0] if units else "",
                        "raw_text": search_text,
                        "confidence": 0.8  # 基础置信度
                    }
        
        return None
    
    def process_health_report(self, image_path: str) -> Dict[str, any]:
        """处理体检报告的完整流程"""
        try:
            logger.info(f"开始处理体检报告: {image_path}")
            
            # 1. 提取文字
            extracted_text = self.extract_text(image_path)
            if not extracted_text:
                raise ValueError("未能从图片中提取到文字")
            
            # 2. 解析健康指标
            indicators = self.parse_health_indicators(extracted_text)
            
            # 3. 构建结果
            result = {
                "status": "success",
                "raw_text": [item[0] for item in extracted_text],
                "confidence_scores": [item[1] for item in extracted_text],
                "health_indicators": indicators,
                "processing_info": {
                    "total_text_segments": len(extracted_text),
                    "indicators_found": len(indicators),
                    "avg_confidence": sum(item[1] for item in extracted_text) / len(extracted_text) if extracted_text else 0
                }
            }
            
            logger.info(f"体检报告处理完成，识别到 {len(indicators)} 类指标")
            return result
            
        except Exception as e:
            logger.error(f"体检报告处理失败: {e}")
            return {
                "status": "error",
                "error": str(e),
                "raw_text": [],
                "health_indicators": {}
            }

# 全局OCR实例
ocr_service = HealthReportOCR()
```

### 2. OCR API端点 (app/api/reports.py)
```python
from fastapi import APIRouter, UploadFile, File, Depends, HTTPException
from sqlalchemy.orm import Session
from app.services.ocr_service import ocr_service
from app.services.ai_service import ai_service
from app.core.database import get_db
from app.utils.file_handler import save_upload_file, validate_file
import tempfile
import os

router = APIRouter(prefix="/api/reports", tags=["reports"])

@router.post("/upload")
async def upload_report(
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """上传并解析体检报告"""
    try:
        # 1. 验证文件
        validate_file(file)
        
        # 2. 保存文件
        file_path = await save_upload_file(file)
        
        # 3. OCR处理
        ocr_result = ocr_service.process_health_report(file_path)
        
        if ocr_result["status"] != "success":
            raise HTTPException(status_code=400, detail=f"OCR处理失败: {ocr_result.get('error')}")
        
        # 4. 保存到数据库
        report = create_health_report(
            db=db,
            user_id=current_user.id,
            file_path=file_path,
            file_name=file.filename,
            ocr_result=ocr_result
        )
        
        return {
            "status": "success",
            "report_id": report.id,
            "indicators_found": len(ocr_result["health_indicators"]),
            "processing_info": ocr_result["processing_info"]
        }
        
    except Exception as e:
        logger.error(f"报告上传失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{report_id}/analyze")
async def analyze_report(
    report_id: str,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """触发AI解读分析"""
    try:
        # 获取报告数据
        report = get_health_report(db, report_id, current_user.id)
        if not report:
            raise HTTPException(status_code=404, detail="报告不存在")
        
        # AI分析
        analysis_result = await ai_service.analyze_health_report(
            indicators=report.health_indicators,
            user_profile=current_user.profile
        )
        
        # 保存分析结果
        interpretation = create_report_interpretation(
            db=db,
            report_id=report_id,
            analysis_result=analysis_result
        )
        
        return {
            "status": "success",
            "interpretation_id": interpretation.id,
            "analysis": analysis_result
        }
        
    except Exception as e:
        logger.error(f"报告分析失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

## 🤖 Azure OpenAI集成

### 1. AI服务实现 (app/services/ai_service.py)
```python
from openai import AzureOpenAI
from typing import Dict, List, Optional
import json
import logging
from app.core.settings import settings

logger = logging.getLogger(__name__)

class HealthAIService:
    def __init__(self):
        """初始化Azure OpenAI客户端"""
        try:
            self.client = AzureOpenAI(
                azure_endpoint=settings.AZURE_OPENAI_ENDPOINT,
                api_key=settings.AZURE_OPENAI_KEY,
                api_version=settings.AZURE_OPENAI_VERSION
            )
            self.deployment_name = settings.AZURE_OPENAI_DEPLOYMENT
            logger.info("Azure OpenAI服务初始化成功")
        except Exception as e:
            logger.error(f"Azure OpenAI服务初始化失败: {e}")
            raise
    
    def _build_health_analysis_prompt(self, indicators: Dict, user_profile: Dict) -> str:
        """构建健康分析的提示词"""
        prompt = f"""
你是一位经验丰富的全科医生，请根据以下体检数据为患者提供专业且通俗的健康分析。

患者基本信息：
- 年龄：{user_profile.get('age', '未知')}岁
- 性别：{user_profile.get('gender', '未知')}
- 既往病史：{user_profile.get('medical_history', '无')}

体检指标数据：
{json.dumps(indicators, ensure_ascii=False, indent=2)}

请按以下结构提供分析（使用JSON格式）：
{{
    "overall_status": "优秀/良好/注意/建议就医",
    "health_score": 85, // 0-100分
    "summary": "整体健康状况简要总结",
    "detailed_analysis": {{
        "normal_indicators": ["正常指标列表"],
        "abnormal_indicators": [
            {{
                "name": "指标名称",
                "value": "检查值",
                "normal_range": "正常范围", 
                "status": "偏高/偏低/严重异常",
                "explanation": "通俗易懂的解释",
                "severity": "轻微/中等/严重"
            }}
        ]
    }},
    "health_risks": [
        {{
            "risk_type": "风险类型",
            "probability": "低/中/高",
            "description": "风险描述",
            "timeframe": "短期/长期"
        }}
    ],
    "recommendations": {{
        "lifestyle": ["生活方式建议"],
        "diet": ["饮食建议"], 
        "exercise": ["运动建议"],
        "follow_up": ["复查建议"]
    }},
    "next_checkup": {{
        "timeframe": "建议复查时间",
        "focus_areas": ["重点关注项目"]
    }}
}}

注意事项：
1. 使用通俗易懂的语言，避免过多医学术语
2. 客观分析，不要过度解读
3. 如果数据不足，请明确说明
4. 建议就医的情况要明确指出
"""
        return prompt
    
    async def analyze_health_report(self, indicators: Dict, user_profile: Dict) -> Dict:
        """分析体检报告"""
        try:
            prompt = self._build_health_analysis_prompt(indicators, user_profile)
            
            response = self.client.chat.completions.create(
                model=self.deployment_name,
                messages=[
                    {"role": "system", "content": "你是一位专业的全科医生，擅长解读体检报告并给出通俗易懂的健康建议。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=2000
            )
            
            # 解析AI回复
            ai_response = response.choices[0].message.content
            
            try:
                # 尝试解析JSON格式的回复
                analysis_result = json.loads(ai_response)
            except json.JSONDecodeError:
                # 如果不是JSON格式，创建基础结构
                analysis_result = {
                    "overall_status": "需要进一步分析",
                    "health_score": 70,
                    "summary": ai_response[:200] + "...",
                    "raw_response": ai_response
                }
            
            logger.info("健康报告AI分析完成")
            return analysis_result
            
        except Exception as e:
            logger.error(f"AI分析失败: {e}")
            return {
                "overall_status": "分析失败",
                "health_score": 0,
                "summary": f"AI分析过程中出现错误: {str(e)}",
                "error": str(e)
            }
    
    async def health_chat(self, question: str, user_context: Dict, chat_history: List = None) -> str:
        """健康问答聊天"""
        try:
            # 构建对话上下文
            system_prompt = f"""
你是一位专业的健康咨询AI助手，基于用户的健康档案回答问题。

用户健康背景：
- 年龄：{user_context.get('age', '未知')}岁
- 性别：{user_context.get('gender', '未知')}
- 最近体检状况：{user_context.get('latest_health_status', '暂无数据')}
- 既往病史：{user_context.get('medical_history', '无')}

回答原则：
1. 基于用户的具体情况给出个性化建议
2. 使用通俗易懂的语言
3. 涉及严重症状时建议就医
4. 不能替代专业医疗诊断
5. 保持客观和谨慎
"""
            
            messages = [{"role": "system", "content": system_prompt}]
            
            # 添加聊天历史
            if chat_history:
                messages.extend(chat_history[-6:])  # 只保留最近3轮对话
            
            messages.append({"role": "user", "content": question})
            
            response = self.client.chat.completions.create(
                model=self.deployment_name,
                messages=messages,
                temperature=0.5,
                max_tokens=800
            )
            
            answer = response.choices[0].message.content
            logger.info("健康问答完成")
            return answer
            
        except Exception as e:
            logger.error(f"健康问答失败: {e}")
            return f"抱歉，我现在无法回答您的问题。请稍后再试。错误信息：{str(e)}"

# 全局AI服务实例
ai_service = HealthAIService()
```

## 🗄️ Supabase数据库集成

### 1. 数据库连接 (app/core/database.py)
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.settings import settings
import logging

logger = logging.getLogger(__name__)

# 创建数据库引擎
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=300,
    echo=settings.DEBUG
)

# 会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 基础模型类
Base = declarative_base()

def get_db():
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"数据库会话错误: {e}")
        db.rollback()
        raise
    finally:
        db.close()
```

### 2. 数据库表结构 (SQL脚本)
```sql
-- 在Supabase SQL编辑器中执行

-- 用户扩展信息表
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    age INTEGER,
    gender VARCHAR(10) CHECK (gender IN ('男', '女', '其他')),
    height FLOAT CHECK (height > 0 AND height < 300),
    weight FLOAT CHECK (weight > 0 AND weight < 500),
    medical_history TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 体检报告表
CREATE TABLE IF NOT EXISTS health_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_path TEXT NOT NULL,
    file_name TEXT NOT NULL,
    file_size INTEGER,
    report_date DATE,
    hospital_name TEXT,
    status VARCHAR(20) DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
    ocr_result JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 解读结果表
CREATE TABLE IF NOT EXISTS report_interpretations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID REFERENCES health_reports(id) ON DELETE CASCADE,
    overall_status VARCHAR(20) CHECK (overall_status IN ('优秀', '良好', '注意', '建议就医')),
    health_score INTEGER CHECK (health_score >= 0 AND health_score <= 100),
    ai_analysis JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 健康指标表
CREATE TABLE IF NOT EXISTS health_indicators (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID REFERENCES health_reports(id) ON DELETE CASCADE,
    category VARCHAR(50) NOT NULL, -- 血常规、血脂等
    indicator_name VARCHAR(100) NOT NULL,
    value FLOAT,
    unit VARCHAR(20),
    normal_range TEXT,
    status VARCHAR(20) CHECK (status IN ('normal', 'high', 'low', 'critical')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 日常健康数据表
CREATE TABLE IF NOT EXISTS daily_health_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    data_type VARCHAR(50) NOT NULL, -- blood_pressure, weight, blood_sugar等
    value JSONB NOT NULL, -- 存储复杂数据
    recorded_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- AI对话记录表
CREATE TABLE IF NOT EXISTS ai_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    context JSONB, -- 对话上下文
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 用户订阅表
CREATE TABLE IF NOT EXISTS user_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    plan_type VARCHAR(20) DEFAULT 'free' CHECK (plan_type IN ('free', 'premium')),
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled', 'expired')),
    start_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 使用量统计表
CREATE TABLE IF NOT EXISTS usage_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type VARCHAR(50) NOT NULL, -- report_analysis, ai_chat等
    count INTEGER DEFAULT 1,
    date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, action_type, date)
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_reports_user_id ON health_reports(user_id);
CREATE INDEX IF NOT EXISTS idx_reports_created_at ON health_reports(created_at);
CREATE INDEX IF NOT EXISTS idx_indicators_report_id ON health_indicators(report_id);
CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON ai_conversations(user_id);
CREATE INDEX IF NOT EXISTS idx_health_data_user_id ON daily_health_data(user_id);
CREATE INDEX IF NOT EXISTS idx_health_data_recorded_at ON daily_health_data(recorded_at);

-- RLS安全策略
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE health_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE report_interpretations ENABLE ROW LEVEL SECURITY;
ALTER TABLE health_indicators ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_health_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_stats ENABLE ROW LEVEL SECURITY;

-- 用户只能访问自己的数据
CREATE POLICY "Users can view own profiles" ON profiles FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users can view own reports" ON health_reports FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users can view own conversations" ON ai_conversations FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users can view own health data" ON daily_health_data FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users can view own subscriptions" ON user_subscriptions FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users can view own usage stats" ON usage_stats FOR ALL USING (auth.uid() = user_id);
```

## 🚀 部署配置

### 1. Docker配置 (Dockerfile)
```dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    libsm6 \
    libxext6 \
    libxrender-dev \
    libgomp1 \
    wget \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2. 环境变量配置 (.env.example)
```env
# 应用配置
APP_NAME=健康AI助手
DEBUG=false
SECRET_KEY=your-secret-key-here

# Supabase配置
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key
DATABASE_URL=postgresql://postgres:password@localhost:5432/health_ai

# Azure OpenAI配置
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/
AZURE_OPENAI_KEY=your-azure-openai-key
AZURE_OPENAI_VERSION=2023-12-01-preview
AZURE_OPENAI_DEPLOYMENT=gpt-4

# Redis配置
REDIS_URL=redis://localhost:6379

# 文件上传配置
MAX_FILE_SIZE=10485760
UPLOAD_PATH=uploads/

# OCR配置
OCR_GPU=false
```

### 3. 启动脚本 (start.sh)
```bash
#!/bin/bash

# 检查环境变量
if [ ! -f .env ]; then
    echo "错误：.env文件不存在"
    exit 1
fi

# 加载环境变量
source .env

# 检查必要的环境变量
required_vars=("SUPABASE_URL" "SUPABASE_KEY" "AZURE_OPENAI_ENDPOINT" "AZURE_OPENAI_KEY")
for var in "${required_vars[@]}"; do
    if [ -z "${!var}" ]; then
        echo "错误：环境变量 $var 未设置"
        exit 1
    fi
done

# 创建上传目录
mkdir -p $UPLOAD_PATH

# 启动应用
echo "启动健康AI助手后端服务..."
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

## 📝 开发工作流

### 1. 本地开发环境搭建
```bash
# 1. 克隆项目
git clone <project-url>
cd health-ai-backend

# 2. 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
# 或 venv\Scripts\activate  # Windows

# 3. 安装依赖
pip install -r requirements.txt

# 4. 配置环境变量
cp .env.example .env
# 编辑.env文件，填入实际配置

# 5. 启动开发服务器
chmod +x start.sh
./start.sh
```

### 2. API测试
访问 `http://localhost:8000/docs` 查看自动生成的API文档

### 3. 前端集成
在Next.js项目中创建API代理：
```typescript
// app/api/proxy/[...path]/route.ts
export async function POST(request: Request, { params }: { params: { path: string[] } }) {
  const body = await request.json()
  const path = params.path.join('/')
  
  const response = await fetch(`${process.env.PYTHON_API_URL}/${path}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': request.headers.get('Authorization') || '',
    },
    body: JSON.stringify(body)
  })
  
  return response
}
```

这个技术实现指南提供了完整的Python后端搭建流程，包括EasyOCR集成、Azure OpenAI配置和Supabase数据库设计。所有代码都是生产就绪的，可以直接用于MVP开发。 